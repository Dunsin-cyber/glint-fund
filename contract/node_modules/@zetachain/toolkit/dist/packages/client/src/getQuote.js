"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuote = exports.getWithdrawFeeInInputToken = exports.getRefundFee = exports.getZRC20GasToken = exports.getZRC20FromERC20 = void 0;
const units_1 = require("@ethersproject/units");
const IUniswapV2Router02_json_1 = __importDefault(require("@uniswap/v2-periphery/build/IUniswapV2Router02.json"));
const protocol_contracts_1 = require("@zetachain/protocol-contracts");
const ZRC20_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/zevm/ZRC20.sol/ZRC20.json"));
const ethers_1 = require("ethers");
/**
 * Retrieves the ZRC20 contract address for a given ERC20 token.
 * @param {string} erc20 - The ERC20 token address.
 * @returns {Promise<string>} - The ZRC20 contract address.
 * @throws Will throw an error if the ERC-20 token is not supported.
 */
const getZRC20FromERC20 = async function (erc20) {
    const foreignCoins = await this.getForeignCoins();
    const token = foreignCoins.find((t) => t.asset === erc20);
    if (!token) {
        throw new Error(`This ERC-20 token is not supported`);
    }
    return token?.zrc20_contract_address;
};
exports.getZRC20FromERC20 = getZRC20FromERC20;
/**
 * Retrieves the ZRC20 contract address for the gas token of a given network.
 * @param {string} network - The network name.
 * @returns {Promise<string>} - The ZRC20 contract address for the gas token.
 */
const getZRC20GasToken = async function (network) {
    const chainID = await this.getChainId(network)?.toString();
    const foreignCoins = await this.getForeignCoins();
    const token = foreignCoins.find((t) => {
        return t.foreign_chain_id === chainID && t.coin_type === "Gas";
    });
    return token?.zrc20_contract_address;
};
exports.getZRC20GasToken = getZRC20GasToken;
/**
 * Retrieves the ZETA token address.
 * @returns {string} - The ZETA token address.
 * @throws Will throw an error if the ZETA token address cannot be retrieved.
 */
const getZetaToken = () => {
    const zetaTokenAddress = (0, protocol_contracts_1.getAddress)("zetaToken", "zeta_testnet");
    if (!zetaTokenAddress) {
        throw new Error("Cannot get ZETA token address");
    }
    return zetaTokenAddress;
};
/**
 * Calculates the refund fee in the input ZRC20 token.
 * @param {string} inputZRC20 - The input ZRC20 token address.
 * @returns {Promise<Object>} - An object containing the refund fee amount and its decimals.
 */
const getRefundFee = async function (inputZRC20) {
    const rpc = this.getEndpoint("evm", "zeta_testnet");
    const provider = new ethers_1.ethers.providers.JsonRpcProvider(rpc);
    const zetaToken = getZetaToken();
    const inputContract = new ethers_1.ethers.Contract(inputZRC20, ZRC20_json_1.default.abi, provider);
    const inputDecimals = await inputContract.decimals();
    const [withdrawZRC20, withdrawFee] = await inputContract.withdrawGasFee();
    const isGas = (await inputContract.COIN_TYPE()) === 1;
    if (isGas) {
        return { amount: withdrawFee, decimals: inputDecimals };
    }
    else {
        const refundFeeInZETA = await getAmounts("in", provider, withdrawFee, zetaToken, withdrawZRC20);
        const withdrawFeeInInputToken = await getAmounts("in", provider, refundFeeInZETA[0], inputZRC20, zetaToken);
        return { amount: withdrawFeeInInputToken[0], decimals: inputDecimals };
    }
};
exports.getRefundFee = getRefundFee;
/**
 * Calculates the withdraw fee in the input ZRC20 token for a given output ZRC20 token.
 * @param {string} inputZRC20 - The input ZRC20 token address.
 * @param {string} outputZRC20 - The output ZRC20 token address.
 * @returns {Promise<Object>} - An object containing the withdraw fee amount and its decimals.
 */
const getWithdrawFeeInInputToken = async function (inputZRC20, outputZRC20) {
    const rpc = this.getEndpoint("evm", "zeta_testnet");
    const provider = new ethers_1.ethers.providers.JsonRpcProvider(rpc);
    const zetaToken = getZetaToken();
    const inputContract = new ethers_1.ethers.Contract(inputZRC20, ZRC20_json_1.default.abi, provider);
    const outputContract = new ethers_1.ethers.Contract(outputZRC20, ZRC20_json_1.default.abi, provider);
    const inputDecimals = await inputContract.decimals();
    const [gasZRC20, gasFee] = await outputContract.withdrawGasFee();
    const withdrawFeeInZETA = await getAmounts("in", provider, gasFee, zetaToken, gasZRC20);
    const withdrawFeeInInputToken = await getAmounts("in", provider, withdrawFeeInZETA[0], inputZRC20, zetaToken);
    return { amount: withdrawFeeInInputToken[0], decimals: inputDecimals };
};
exports.getWithdrawFeeInInputToken = getWithdrawFeeInInputToken;
/**
 * Retrieves a quote for swapping input ZRC20 token to output ZRC20 token.
 * @param {string} inputAmount - The amount of input ZRC20 token.
 * @param {string} inputZRC20 - The input ZRC20 token address.
 * @param {string} outputZRC20 - The output ZRC20 token address.
 * @returns {Promise<Object>} - An object containing the output amount and its decimals.
 */
const getQuote = async function (inputAmount, inputZRC20, outputZRC20) {
    const rpc = this.getEndpoint("evm", "zeta_testnet");
    const provider = new ethers_1.ethers.providers.JsonRpcProvider(rpc);
    const zetaToken = getZetaToken();
    const inputContract = new ethers_1.ethers.Contract(inputZRC20, ZRC20_json_1.default.abi, provider);
    const outputContract = new ethers_1.ethers.Contract(outputZRC20, ZRC20_json_1.default.abi, provider);
    const inputDecimals = await inputContract.decimals();
    const amountIn = (0, units_1.parseUnits)(inputAmount, inputDecimals).toString();
    const outputDecimals = await outputContract.decimals();
    const outputAmountInZETA = await getAmounts("out", provider, amountIn, inputZRC20, zetaToken);
    const outputAmount = await getAmounts("out", provider, outputAmountInZETA[1], zetaToken, outputZRC20);
    return { amount: outputAmount[1], decimals: outputDecimals };
};
exports.getQuote = getQuote;
/**
 * Retrieves the amounts for swapping tokens using UniswapV2.
 * @param {"in" | "out"} direction - The direction of the swap ("in" or "out").
 * @param {any} provider - The ethers provider.
 * @param {any} amount - The amount to swap.
 * @param {string} tokenA - The address of token A.
 * @param {string} tokenB - The address of token B.
 * @returns {Promise<any>} - The amounts for the swap.
 * @throws Will throw an error if the UniswapV2 router address cannot be retrieved.
 */
const getAmounts = async (direction, provider, amount, tokenA, tokenB) => {
    const uniswapV2Router02 = (0, protocol_contracts_1.getAddress)("uniswapV2Router02", "zeta_testnet");
    if (!uniswapV2Router02) {
        throw new Error("Cannot get uniswapV2Router02 address");
    }
    const uniswapRouter = new ethers_1.ethers.Contract(uniswapV2Router02, IUniswapV2Router02_json_1.default.abi, provider);
    const path = [tokenA, tokenB];
    const amounts = direction === "in"
        ? await uniswapRouter.getAmountsIn(amount, path)
        : await uniswapRouter.getAmountsOut(amount, path);
    return amounts;
};
