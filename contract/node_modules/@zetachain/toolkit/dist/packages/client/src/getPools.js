"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPools = void 0;
const UniswapV2Pair_json_1 = __importDefault(require("@uniswap/v2-core/build/UniswapV2Pair.json"));
const protocol_contracts_1 = require("@zetachain/protocol-contracts");
const SystemContract_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/zevm/SystemContract.sol/SystemContract.json"));
const ethers_1 = require("ethers");
const getPools = async function () {
    const rpc = this.getEndpoint("evm", `zeta_${this.network}`);
    const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(rpc);
    const zetaNetwork = `zeta_${this.network}`;
    const uniswapV2FactoryAddress = (0, protocol_contracts_1.getAddress)("uniswapV2Factory", zetaNetwork);
    if (!uniswapV2FactoryAddress) {
        throw new Error("uniswapV2Factory is not defined");
    }
    const systemContractAddress = (0, protocol_contracts_1.getAddress)("systemContract", zetaNetwork);
    if (!systemContractAddress) {
        throw new Error("System contract is not defined");
    }
    const systemContract = new ethers_1.ethers.Contract(systemContractAddress, SystemContract_json_1.default.abi, provider);
    const zetaTokenAddress = (0, protocol_contracts_1.getAddress)("zetaToken", zetaNetwork);
    if (!zetaTokenAddress) {
        throw new Error("ZETA token address is not defined");
    }
    const foreignCoins = await this.getForeignCoins();
    const tokenAddresses = foreignCoins.map((coin) => coin.zrc20_contract_address);
    tokenAddresses.push(zetaTokenAddress);
    const uniquePairs = tokenAddresses.reduce((pairs, tokenA, i) => {
        tokenAddresses.slice(i + 1).forEach((tokenB) => {
            const pairKey = [tokenA, tokenB].sort().join("-");
            if (!pairs.some((p) => p.key === pairKey)) {
                pairs.push({ key: pairKey, tokenA, tokenB });
            }
        });
        return pairs;
    }, []);
    const poolPromises = uniquePairs.map(async ({ tokenA, tokenB }) => {
        const pair = await systemContract.uniswapv2PairFor(uniswapV2FactoryAddress, tokenA, tokenB);
        if (pair === ethers_1.ethers.constants.AddressZero)
            return null;
        try {
            const pairContract = new ethers_1.ethers.Contract(pair, UniswapV2Pair_json_1.default.abi, provider);
            const [token0, token1] = await Promise.all([
                pairContract.token0(),
                pairContract.token1(),
            ]);
            const reserves = await pairContract.getReserves();
            return {
                pair,
                t0: { address: token0, reserve: reserves[0] },
                t1: { address: token1, reserve: reserves[1] },
            };
        }
        catch (error) {
            return null;
        }
    });
    let pools = (await Promise.all(poolPromises)).filter((pool) => pool !== null);
    const zrc20Details = foreignCoins.reduce((acc, coin) => {
        acc[coin.zrc20_contract_address.toLowerCase()] = {
            decimals: coin.decimals,
            symbol: coin.symbol,
        };
        return acc;
    }, {});
    pools = pools.map((t) => {
        const zeta = { decimals: 18, symbol: "WZETA" };
        const t0 = t.t0.address.toLowerCase();
        const t1 = t.t1.address.toLowerCase();
        const t0ZETA = t0 === zetaTokenAddress.toLowerCase() && zeta;
        const t1ZETA = t1 === zetaTokenAddress.toLowerCase() && zeta;
        return {
            ...t,
            t0: {
                ...t.t0,
                ...(zrc20Details[t0] || t0ZETA),
            },
            t1: {
                ...t.t1,
                ...(zrc20Details[t1] || t1ZETA),
            },
        };
    });
    return pools;
};
exports.getPools = getPools;
